{"ast":null,"code":"import{rectToClientRect,computePosition as computePosition$1}from'@floating-ui/core';export{arrow,autoPlacement,detectOverflow,flip,hide,inline,limitShift,offset,shift,size}from'@floating-ui/core';import{round,createCoords,max,min,floor}from'@floating-ui/utils';import{getComputedStyle,isHTMLElement,isElement,getWindow,isWebKit,getDocumentElement,getNodeName,isOverflowElement,getNodeScroll,getOverflowAncestors,getParentNode,isLastTraversableNode,isContainingBlock,isTableElement,getContainingBlock}from'@floating-ui/utils/dom';export{getOverflowAncestors}from'@floating-ui/utils/dom';function getCssDimensions(element){const css=getComputedStyle(element);// In testing environments, the `width` and `height` properties are empty\n// strings for SVG elements, returning NaN. Fallback to `0` in this case.\nlet width=parseFloat(css.width)||0;let height=parseFloat(css.height)||0;const hasOffset=isHTMLElement(element);const offsetWidth=hasOffset?element.offsetWidth:width;const offsetHeight=hasOffset?element.offsetHeight:height;const shouldFallback=round(width)!==offsetWidth||round(height)!==offsetHeight;if(shouldFallback){width=offsetWidth;height=offsetHeight;}return{width,height,$:shouldFallback};}function unwrapElement(element){return!isElement(element)?element.contextElement:element;}function getScale(element){const domElement=unwrapElement(element);if(!isHTMLElement(domElement)){return createCoords(1);}const rect=domElement.getBoundingClientRect();const{width,height,$}=getCssDimensions(domElement);let x=($?round(rect.width):rect.width)/width;let y=($?round(rect.height):rect.height)/height;// 0, NaN, or Infinity should always fallback to 1.\nif(!x||!Number.isFinite(x)){x=1;}if(!y||!Number.isFinite(y)){y=1;}return{x,y};}const noOffsets=/*#__PURE__*/createCoords(0);function getVisualOffsets(element){const win=getWindow(element);if(!isWebKit()||!win.visualViewport){return noOffsets;}return{x:win.visualViewport.offsetLeft,y:win.visualViewport.offsetTop};}function shouldAddVisualOffsets(element,isFixed,floatingOffsetParent){if(isFixed===void 0){isFixed=false;}if(!floatingOffsetParent||isFixed&&floatingOffsetParent!==getWindow(element)){return false;}return isFixed;}function getBoundingClientRect(element,includeScale,isFixedStrategy,offsetParent){if(includeScale===void 0){includeScale=false;}if(isFixedStrategy===void 0){isFixedStrategy=false;}const clientRect=element.getBoundingClientRect();const domElement=unwrapElement(element);let scale=createCoords(1);if(includeScale){if(offsetParent){if(isElement(offsetParent)){scale=getScale(offsetParent);}}else{scale=getScale(element);}}const visualOffsets=shouldAddVisualOffsets(domElement,isFixedStrategy,offsetParent)?getVisualOffsets(domElement):createCoords(0);let x=(clientRect.left+visualOffsets.x)/scale.x;let y=(clientRect.top+visualOffsets.y)/scale.y;let width=clientRect.width/scale.x;let height=clientRect.height/scale.y;if(domElement){const win=getWindow(domElement);const offsetWin=offsetParent&&isElement(offsetParent)?getWindow(offsetParent):offsetParent;let currentIFrame=win.frameElement;while(currentIFrame&&offsetParent&&offsetWin!==win){const iframeScale=getScale(currentIFrame);const iframeRect=currentIFrame.getBoundingClientRect();const css=getComputedStyle(currentIFrame);const left=iframeRect.left+(currentIFrame.clientLeft+parseFloat(css.paddingLeft))*iframeScale.x;const top=iframeRect.top+(currentIFrame.clientTop+parseFloat(css.paddingTop))*iframeScale.y;x*=iframeScale.x;y*=iframeScale.y;width*=iframeScale.x;height*=iframeScale.y;x+=left;y+=top;currentIFrame=getWindow(currentIFrame).frameElement;}}return rectToClientRect({width,height,x,y});}function convertOffsetParentRelativeRectToViewportRelativeRect(_ref){let{rect,offsetParent,strategy}=_ref;const isOffsetParentAnElement=isHTMLElement(offsetParent);const documentElement=getDocumentElement(offsetParent);if(offsetParent===documentElement){return rect;}let scroll={scrollLeft:0,scrollTop:0};let scale=createCoords(1);const offsets=createCoords(0);if(isOffsetParentAnElement||!isOffsetParentAnElement&&strategy!=='fixed'){if(getNodeName(offsetParent)!=='body'||isOverflowElement(documentElement)){scroll=getNodeScroll(offsetParent);}if(isHTMLElement(offsetParent)){const offsetRect=getBoundingClientRect(offsetParent);scale=getScale(offsetParent);offsets.x=offsetRect.x+offsetParent.clientLeft;offsets.y=offsetRect.y+offsetParent.clientTop;}}return{width:rect.width*scale.x,height:rect.height*scale.y,x:rect.x*scale.x-scroll.scrollLeft*scale.x+offsets.x,y:rect.y*scale.y-scroll.scrollTop*scale.y+offsets.y};}function getClientRects(element){return Array.from(element.getClientRects());}function getWindowScrollBarX(element){// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nreturn getBoundingClientRect(getDocumentElement(element)).left+getNodeScroll(element).scrollLeft;}// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element){const html=getDocumentElement(element);const scroll=getNodeScroll(element);const body=element.ownerDocument.body;const width=max(html.scrollWidth,html.clientWidth,body.scrollWidth,body.clientWidth);const height=max(html.scrollHeight,html.clientHeight,body.scrollHeight,body.clientHeight);let x=-scroll.scrollLeft+getWindowScrollBarX(element);const y=-scroll.scrollTop;if(getComputedStyle(body).direction==='rtl'){x+=max(html.clientWidth,body.clientWidth)-width;}return{width,height,x,y};}function getViewportRect(element,strategy){const win=getWindow(element);const html=getDocumentElement(element);const visualViewport=win.visualViewport;let width=html.clientWidth;let height=html.clientHeight;let x=0;let y=0;if(visualViewport){width=visualViewport.width;height=visualViewport.height;const visualViewportBased=isWebKit();if(!visualViewportBased||visualViewportBased&&strategy==='fixed'){x=visualViewport.offsetLeft;y=visualViewport.offsetTop;}}return{width,height,x,y};}// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element,strategy){const clientRect=getBoundingClientRect(element,true,strategy==='fixed');const top=clientRect.top+element.clientTop;const left=clientRect.left+element.clientLeft;const scale=isHTMLElement(element)?getScale(element):createCoords(1);const width=element.clientWidth*scale.x;const height=element.clientHeight*scale.y;const x=left*scale.x;const y=top*scale.y;return{width,height,x,y};}function getClientRectFromClippingAncestor(element,clippingAncestor,strategy){let rect;if(clippingAncestor==='viewport'){rect=getViewportRect(element,strategy);}else if(clippingAncestor==='document'){rect=getDocumentRect(getDocumentElement(element));}else if(isElement(clippingAncestor)){rect=getInnerBoundingClientRect(clippingAncestor,strategy);}else{const visualOffsets=getVisualOffsets(element);rect={...clippingAncestor,x:clippingAncestor.x-visualOffsets.x,y:clippingAncestor.y-visualOffsets.y};}return rectToClientRect(rect);}function hasFixedPositionAncestor(element,stopNode){const parentNode=getParentNode(element);if(parentNode===stopNode||!isElement(parentNode)||isLastTraversableNode(parentNode)){return false;}return getComputedStyle(parentNode).position==='fixed'||hasFixedPositionAncestor(parentNode,stopNode);}// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element,cache){const cachedResult=cache.get(element);if(cachedResult){return cachedResult;}let result=getOverflowAncestors(element,[],false).filter(el=>isElement(el)&&getNodeName(el)!=='body');let currentContainingBlockComputedStyle=null;const elementIsFixed=getComputedStyle(element).position==='fixed';let currentNode=elementIsFixed?getParentNode(element):element;// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\nwhile(isElement(currentNode)&&!isLastTraversableNode(currentNode)){const computedStyle=getComputedStyle(currentNode);const currentNodeIsContaining=isContainingBlock(currentNode);if(!currentNodeIsContaining&&computedStyle.position==='fixed'){currentContainingBlockComputedStyle=null;}const shouldDropCurrentNode=elementIsFixed?!currentNodeIsContaining&&!currentContainingBlockComputedStyle:!currentNodeIsContaining&&computedStyle.position==='static'&&!!currentContainingBlockComputedStyle&&['absolute','fixed'].includes(currentContainingBlockComputedStyle.position)||isOverflowElement(currentNode)&&!currentNodeIsContaining&&hasFixedPositionAncestor(element,currentNode);if(shouldDropCurrentNode){// Drop non-containing blocks.\nresult=result.filter(ancestor=>ancestor!==currentNode);}else{// Record last containing block for next iteration.\ncurrentContainingBlockComputedStyle=computedStyle;}currentNode=getParentNode(currentNode);}cache.set(element,result);return result;}// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref){let{element,boundary,rootBoundary,strategy}=_ref;const elementClippingAncestors=boundary==='clippingAncestors'?getClippingElementAncestors(element,this._c):[].concat(boundary);const clippingAncestors=[...elementClippingAncestors,rootBoundary];const firstClippingAncestor=clippingAncestors[0];const clippingRect=clippingAncestors.reduce((accRect,clippingAncestor)=>{const rect=getClientRectFromClippingAncestor(element,clippingAncestor,strategy);accRect.top=max(rect.top,accRect.top);accRect.right=min(rect.right,accRect.right);accRect.bottom=min(rect.bottom,accRect.bottom);accRect.left=max(rect.left,accRect.left);return accRect;},getClientRectFromClippingAncestor(element,firstClippingAncestor,strategy));return{width:clippingRect.right-clippingRect.left,height:clippingRect.bottom-clippingRect.top,x:clippingRect.left,y:clippingRect.top};}function getDimensions(element){return getCssDimensions(element);}function getRectRelativeToOffsetParent(element,offsetParent,strategy){const isOffsetParentAnElement=isHTMLElement(offsetParent);const documentElement=getDocumentElement(offsetParent);const isFixed=strategy==='fixed';const rect=getBoundingClientRect(element,true,isFixed,offsetParent);let scroll={scrollLeft:0,scrollTop:0};const offsets=createCoords(0);if(isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed){if(getNodeName(offsetParent)!=='body'||isOverflowElement(documentElement)){scroll=getNodeScroll(offsetParent);}if(isOffsetParentAnElement){const offsetRect=getBoundingClientRect(offsetParent,true,isFixed,offsetParent);offsets.x=offsetRect.x+offsetParent.clientLeft;offsets.y=offsetRect.y+offsetParent.clientTop;}else if(documentElement){offsets.x=getWindowScrollBarX(documentElement);}}return{x:rect.left+scroll.scrollLeft-offsets.x,y:rect.top+scroll.scrollTop-offsets.y,width:rect.width,height:rect.height};}function getTrueOffsetParent(element,polyfill){if(!isHTMLElement(element)||getComputedStyle(element).position==='fixed'){return null;}if(polyfill){return polyfill(element);}return element.offsetParent;}// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element,polyfill){const window=getWindow(element);if(!isHTMLElement(element)){return window;}let offsetParent=getTrueOffsetParent(element,polyfill);while(offsetParent&&isTableElement(offsetParent)&&getComputedStyle(offsetParent).position==='static'){offsetParent=getTrueOffsetParent(offsetParent,polyfill);}if(offsetParent&&(getNodeName(offsetParent)==='html'||getNodeName(offsetParent)==='body'&&getComputedStyle(offsetParent).position==='static'&&!isContainingBlock(offsetParent))){return window;}return offsetParent||getContainingBlock(element)||window;}const getElementRects=async function(_ref){let{reference,floating,strategy}=_ref;const getOffsetParentFn=this.getOffsetParent||getOffsetParent;const getDimensionsFn=this.getDimensions;return{reference:getRectRelativeToOffsetParent(reference,await getOffsetParentFn(floating),strategy),floating:{x:0,y:0,...(await getDimensionsFn(floating))}};};function isRTL(element){return getComputedStyle(element).direction==='rtl';}const platform={convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement,getClippingRect,getOffsetParent,getElementRects,getClientRects,getDimensions,getScale,isElement,isRTL};// https://samthor.au/2021/observing-dom/\nfunction observeMove(element,onMove){let io=null;let timeoutId;const root=getDocumentElement(element);function cleanup(){clearTimeout(timeoutId);io&&io.disconnect();io=null;}function refresh(skip,threshold){if(skip===void 0){skip=false;}if(threshold===void 0){threshold=1;}cleanup();const{left,top,width,height}=element.getBoundingClientRect();if(!skip){onMove();}if(!width||!height){return;}const insetTop=floor(top);const insetRight=floor(root.clientWidth-(left+width));const insetBottom=floor(root.clientHeight-(top+height));const insetLeft=floor(left);const rootMargin=-insetTop+\"px \"+-insetRight+\"px \"+-insetBottom+\"px \"+-insetLeft+\"px\";const options={rootMargin,threshold:max(0,min(1,threshold))||1};let isFirstUpdate=true;function handleObserve(entries){const ratio=entries[0].intersectionRatio;if(ratio!==threshold){if(!isFirstUpdate){return refresh();}if(!ratio){timeoutId=setTimeout(()=>{refresh(false,1e-7);},100);}else{refresh(false,ratio);}}isFirstUpdate=false;}// Older browsers don't support a `document` as the root and will throw an\n// error.\ntry{io=new IntersectionObserver(handleObserve,{...options,// Handle <iframe>s\nroot:root.ownerDocument});}catch(e){io=new IntersectionObserver(handleObserve,options);}io.observe(element);}refresh(true);return cleanup;}/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */function autoUpdate(reference,floating,update,options){if(options===void 0){options={};}const{ancestorScroll=true,ancestorResize=true,elementResize=typeof ResizeObserver==='function',layoutShift=typeof IntersectionObserver==='function',animationFrame=false}=options;const referenceEl=unwrapElement(reference);const ancestors=ancestorScroll||ancestorResize?[...(referenceEl?getOverflowAncestors(referenceEl):[]),...getOverflowAncestors(floating)]:[];ancestors.forEach(ancestor=>{ancestorScroll&&ancestor.addEventListener('scroll',update,{passive:true});ancestorResize&&ancestor.addEventListener('resize',update);});const cleanupIo=referenceEl&&layoutShift?observeMove(referenceEl,update):null;let reobserveFrame=-1;let resizeObserver=null;if(elementResize){resizeObserver=new ResizeObserver(_ref=>{let[firstEntry]=_ref;if(firstEntry&&firstEntry.target===referenceEl&&resizeObserver){// Prevent update loops when using the `size` middleware.\n// https://github.com/floating-ui/floating-ui/issues/1740\nresizeObserver.unobserve(floating);cancelAnimationFrame(reobserveFrame);reobserveFrame=requestAnimationFrame(()=>{resizeObserver&&resizeObserver.observe(floating);});}update();});if(referenceEl&&!animationFrame){resizeObserver.observe(referenceEl);}resizeObserver.observe(floating);}let frameId;let prevRefRect=animationFrame?getBoundingClientRect(reference):null;if(animationFrame){frameLoop();}function frameLoop(){const nextRefRect=getBoundingClientRect(reference);if(prevRefRect&&(nextRefRect.x!==prevRefRect.x||nextRefRect.y!==prevRefRect.y||nextRefRect.width!==prevRefRect.width||nextRefRect.height!==prevRefRect.height)){update();}prevRefRect=nextRefRect;frameId=requestAnimationFrame(frameLoop);}update();return()=>{ancestors.forEach(ancestor=>{ancestorScroll&&ancestor.removeEventListener('scroll',update);ancestorResize&&ancestor.removeEventListener('resize',update);});cleanupIo&&cleanupIo();resizeObserver&&resizeObserver.disconnect();resizeObserver=null;if(animationFrame){cancelAnimationFrame(frameId);}};}/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */const computePosition=(reference,floating,options)=>{// This caches the expensive `getClippingElementAncestors` function so that\n// multiple lifecycle resets re-use the same result. It only lives for a\n// single call. If other functions become expensive, we can add them as well.\nconst cache=new Map();const mergedOptions={platform,...options};const platformWithCache={...mergedOptions.platform,_c:cache};return computePosition$1(reference,floating,{...mergedOptions,platform:platformWithCache});};export{autoUpdate,computePosition,platform};","map":{"version":3,"names":["rectToClientRect","computePosition","computePosition$1","arrow","autoPlacement","detectOverflow","flip","hide","inline","limitShift","offset","shift","size","round","createCoords","max","min","floor","getComputedStyle","isHTMLElement","isElement","getWindow","isWebKit","getDocumentElement","getNodeName","isOverflowElement","getNodeScroll","getOverflowAncestors","getParentNode","isLastTraversableNode","isContainingBlock","isTableElement","getContainingBlock","getCssDimensions","element","css","width","parseFloat","height","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","contextElement","getScale","domElement","rect","getBoundingClientRect","x","y","Number","isFinite","noOffsets","getVisualOffsets","win","visualViewport","offsetLeft","offsetTop","shouldAddVisualOffsets","isFixed","floatingOffsetParent","includeScale","isFixedStrategy","offsetParent","clientRect","scale","visualOffsets","left","top","offsetWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","convertOffsetParentRelativeRectToViewportRelativeRect","_ref","strategy","isOffsetParentAnElement","documentElement","scroll","scrollLeft","scrollTop","offsets","offsetRect","getClientRects","Array","from","getWindowScrollBarX","getDocumentRect","html","body","ownerDocument","scrollWidth","clientWidth","scrollHeight","clientHeight","direction","getViewportRect","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","parentNode","position","getClippingElementAncestors","cache","cachedResult","get","result","filter","el","currentContainingBlockComputedStyle","elementIsFixed","currentNode","computedStyle","currentNodeIsContaining","shouldDropCurrentNode","includes","ancestor","set","getClippingRect","boundary","rootBoundary","elementClippingAncestors","_c","concat","clippingAncestors","firstClippingAncestor","clippingRect","reduce","accRect","right","bottom","getDimensions","getRectRelativeToOffsetParent","getTrueOffsetParent","polyfill","getOffsetParent","window","getElementRects","reference","floating","getOffsetParentFn","getDimensionsFn","isRTL","platform","observeMove","onMove","io","timeoutId","root","cleanup","clearTimeout","disconnect","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","rootMargin","options","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","setTimeout","IntersectionObserver","e","observe","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","animationFrame","referenceEl","ancestors","forEach","addEventListener","passive","cleanupIo","reobserveFrame","resizeObserver","firstEntry","target","unobserve","cancelAnimationFrame","requestAnimationFrame","frameId","prevRefRect","frameLoop","nextRefRect","removeEventListener","Map","mergedOptions","platformWithCache"],"sources":["/Users/venkataramanasripada/Desktop/ece-skule-ca/src/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs"],"sourcesContent":["import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}